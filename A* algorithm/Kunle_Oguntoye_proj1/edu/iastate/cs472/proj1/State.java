package edu.iastate.cs472.proj1;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below:
 *
 *  1 2 3
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object
 * of the State class.
 *
 * @author Kunle Oguntoye
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state 
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the 
	                                        // goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double 
										    // move counted as one; negative if not computed yet. 

	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException
    {
        if (board == null) {
            this.board = null;  // Set board to null for dummy node
            this.previous = null;
            this.next = null;
            this.predecessor = null;
            this.move = null;
            this.numMoves = 0;
            return;  // Exit early, no need to validate or initialize further
        }
        if (board.length != 3 || board[0].length != 3) {
            throw new IllegalArgumentException("Board must be a 3x3 array.");
        }
        // Ensure the board contains the digits 0 to 8 exactly once
        Set<Integer> seen = new HashSet<>();  // To track digits we have seen
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                int value = board[i][j];
                
                // Check if the value is within the valid range (0 to 8)
                if (value < 0 || value > 8) {
                    throw new IllegalArgumentException("Board contains invalid number: " + value);
                }

                // Check for duplicates
                if (!seen.add(value)) {
                    throw new IllegalArgumentException("Board contains duplicate number: " + value);
                }
            }
        }
        this.board = board;

        this.previous = null;
        this.next = null;
        this.predecessor = null;
        this.move = null;
        this.numMoves = 0;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State(String inputFileName) throws FileNotFoundException, IllegalArgumentException {
        this.board = new int[3][3];
        Set<Integer> seen = new HashSet<>();

        try (Scanner scanner = new Scanner(new File(inputFileName))) {
            for (int i = 0; i < 3; i++) {
                if (!scanner.hasNextLine()) {
                    throw new IllegalArgumentException("File doesn't contain enough rows.");
                }
                String line = scanner.nextLine().trim();
                String[] numbers = line.split("\\s+");

                if (numbers.length != 3) {
                    throw new IllegalArgumentException("Each row must contain exactly three digits.");
                }

                for (int j = 0; j < 3; j++) {
                    int num = Integer.parseInt(numbers[j]);
                    if (num < 0 || num > 8 || seen.contains(num)) {
                        throw new IllegalArgumentException("Invalid board configuration.");
                    }
                    seen.add(num);
                    this.board[i][j] = num;
                }
            }
        }

        this.previous = null;
        this.next = null;
        this.predecessor = null;
        this.move = null;
        this.numMoves = 0;
    }

    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException {
        // Step 1: Clone the current state
        State successor = (State) this.clone();
    
        // Step 2: Locate the empty square (0)
        int emptyX = -1, emptyY = -1;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (successor.board[i][j] == 0) {
                    emptyX = i;
                    emptyY = j;
                    break;
                }
            }
            if (emptyX != -1) break;
        }
    
        // Step 3: Perform the move on the cloned board
        switch (m) {
            case LEFT:
                if (emptyY == 2) throw new IllegalArgumentException("Cannot move left.");
                successor.board[emptyX][emptyY] = successor.board[emptyX][emptyY + 1];
                successor.board[emptyX][emptyY + 1] = 0;
                break;
            case RIGHT:
                if (emptyY == 0) throw new IllegalArgumentException("Cannot move right.");
                successor.board[emptyX][emptyY] = successor.board[emptyX][emptyY - 1];
                successor.board[emptyX][emptyY - 1] = 0;
                break;
            case UP:
                if (emptyX == 2) throw new IllegalArgumentException("Cannot move up.");
                successor.board[emptyX][emptyY] = successor.board[emptyX + 1][emptyY];
                successor.board[emptyX + 1][emptyY] = 0;
                break;
            case DOWN:
                if (emptyX == 0) throw new IllegalArgumentException("Cannot move down.");
                successor.board[emptyX][emptyY] = successor.board[emptyX - 1][emptyY];
                successor.board[emptyX - 1][emptyY] = 0;
                break;
    
            case DBL_LEFT:
                if (emptyY >= 1) throw new IllegalArgumentException("Cannot perform double left move.");
                successor.board[emptyX][emptyY] = successor.board[emptyX][emptyY + 1];
                successor.board[emptyX][emptyY + 1] = successor.board[emptyX][emptyY + 2];
                successor.board[emptyX][emptyY + 2] = 0;
                break;
    
            case DBL_RIGHT:
                if (emptyY <= 1) throw new IllegalArgumentException("Cannot perform double right move.");
                successor.board[emptyX][emptyY] = successor.board[emptyX][emptyY - 1];
                successor.board[emptyX][emptyY - 1] = successor.board[emptyX][emptyY - 2];
                successor.board[emptyX][emptyY - 2] = 0;
                break;
    
            case DBL_UP:
                if (emptyX >= 1) throw new IllegalArgumentException("Cannot perform double up move.");
                successor.board[emptyX][emptyY] = successor.board[emptyX + 1][emptyY];
                successor.board[emptyX + 1][emptyY] = successor.board[emptyX + 2][emptyY];
                successor.board[emptyX + 2][emptyY] = 0;
                break;
    
            case DBL_DOWN:
                if (emptyX <= 1) throw new IllegalArgumentException("Cannot perform double down move.");
                successor.board[emptyX][emptyY] = successor.board[emptyX - 1][emptyY];
                successor.board[emptyX - 1][emptyY] = successor.board[emptyX - 2][emptyY];
                successor.board[emptyX - 2][emptyY] = 0;
                break;
    
            default:
                throw new IllegalArgumentException("Invalid move.");
        }
    
        // Step 4: Update successor's metadata
        successor.predecessor = this;   // Set predecessor to current state
        successor.move = m;             // Record the move
        successor.numMoves = this.numMoves + 1;  // Increment the move count
    
        // Step 5: Return null if the successor equals the predecessor
        return successor.equals(this) ? null : successor;
    }
    
    // Helper method to create a deep copy of the board
    private int[][] deepCopyBoard(int[][] original) {
        int[][] copy = new int[original.length][];
        for (int i = 0; i < original.length; i++) {
            copy[i] = original[i].clone();
        }
        return copy;
    }
    

    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     */
    /**
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable() {
        int[] flatInitial = flattenBoard(this.board);
        int[] flatGoal = flattenBoard(new int[][]{
            {1, 2, 3},
            {8, 0, 4},
            {7, 6, 5}
        });
    
        int initialInversions = countInversions(flatInitial);
        int goalInversions = countInversions(flatGoal);
    
        // The puzzle is solvable if the difference in inversion counts is even
        return (Math.abs(initialInversions - goalInversions) % 2 == 0);
    }
    
    // Helper method to flatten the 2D board into a 1D array
    private int[] flattenBoard(int[][] board) {
        int[] flatBoard = new int[9];
        int index = 0;
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                flatBoard[index++] = board[i][j];
            }
        }
        return flatBoard;
    }
    
    // Helper method to count the number of inversions in a 1D array
    private int countInversions(int[] flatBoard) {
        int inversions = 0;
        for (int i = 0; i < flatBoard.length - 1; i++) {
            for (int j = i + 1; j < flatBoard.length; j++) {
                if (flatBoard[i] != 0 && flatBoard[j] != 0 && flatBoard[i] > flatBoard[j]) {
                    inversions++;
                }
            }
        }
        return inversions;
    }


    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState() {
        int[][] goal = { { 1, 2, 3 }, { 8, 0, 4 }, { 7, 6, 5 } };
        return Arrays.deepEquals(this.board, goal);
    }

    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int[] row : board) {
            for (int tile : row) {
                sb.append(tile == 0 ? " " : tile).append(" ");
            }
            sb.append("\n");
        }
        return sb.toString();
    }


    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone() {
        State clone = new State(deepCopyBoard(this.board));
        clone.previous = null;
        clone.next = null;
        clone.predecessor = null;
        clone.move = this.move;
        clone.numMoves = this.numMoves;
        return clone;
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        State state = (State) o;
        return Arrays.deepEquals(board, state.board);
    }


    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic. 
     */
    public int cost() throws IllegalArgumentException {
        switch (heu) {
            case TileMismatch:
                return numMoves + computeNumMismatchedTiles();
            case ManhattanDist:
                return numMoves + computeManhattanDistance();
            case DoubleMoveHeuristic:
                return numMoves + computeNumSingleDoubleMoves();
            default:
                throw new IllegalArgumentException("Invalid heuristic.");
        }
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s) {
        return Integer.compare(this.cost(), s.cost());
    }



    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
  private int computeNumMismatchedTiles() {
        if (numMismatchedTiles >= 0) return numMismatchedTiles;
        int mismatches = 0;
        int[][] goal = { { 1, 2, 3 }, { 8, 0, 4 }, { 7, 6, 5 } };
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] != goal[i][j] && board[i][j] != 0) {
                    mismatches++;
                }
            }
        }
        numMismatchedTiles = mismatches;
        return numMismatchedTiles;
    }
    

	
	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
    private int computeManhattanDistance() {
        if (ManhattanDistance >= 0) {
            return ManhattanDistance; // If already computed, return it
        }
    
        int distance = 0; 
        int[][] goal = { { 1, 2, 3 }, { 8, 0, 4 }, { 7, 6, 5 } };
    
        // Iterate through each tile in the board
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                int value = board[i][j];
    
                // Skip empty tile (0)
                if (value != 0) {
                    // Get the position of the current tile in the goal state
                    int[] goalPos = findGoalPosition(value, goal);
                    
                    // Calculate Manhattan distance for the tile
                    distance += Math.abs(i - goalPos[0]) + Math.abs(j - goalPos[1]);
                }
            }
        }
    
        // Store the computed distance
        ManhattanDistance = distance;
        return ManhattanDistance;
    }
    
    // Helper method to find the position of a tile in the goal state
    private int[] findGoalPosition(int value, int[][] goal) {
        for (int i = 0; i < goal.length; i++) {
            for (int j = 0; j < goal[i].length; j++) {
                if (goal[i][j] == value) {
                    return new int[] { i, j };
                }
            }
        }
        return null; // This should never happen if value is valid
    }
	
	
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value
	 * otherwise.
	 *
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves,
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves()
	{
		if (numSingleDoubleMoves >= 0) {
			return numSingleDoubleMoves;
		}

		// For double moves, we can reduce Manhattan distance by at most 2 per move
		// So the minimum number of moves is ceiling(ManhattanDistance / 2)
		// This is admissible because it never overestimates
		int manhattanDist = computeManhattanDistance();
		numSingleDoubleMoves = (int) Math.ceil(manhattanDist / 2.0);

		return numSingleDoubleMoves;
	}
}
